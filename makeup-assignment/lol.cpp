#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include <queue>
#include <cstdint>
#include <functional>

using namespace std;

constexpr size_t BLOCK_SIZE     = 4096;              // bytes per block
constexpr size_t INT_SIZE       = sizeof(int32_t);   // 4 bytes
constexpr size_t INTS_PER_BLOCK = BLOCK_SIZE / INT_SIZE;

// A node in our minâ€heap, holding a value and which run it came from
struct HeapNode {
    int32_t  value;
    size_t   runIndex;
    bool operator>(HeapNode const &o) const { return value > o.value; }
};

int main() {
    const string INPUT_FILE     = "output_bin_one.bin";
    const string SORTED_OUTPUT  = "sorted_output.bin";


    // just clearing things up
        cout << "========== External Merge Sort: Data Lineage ==========" << endl;
        cout << "1. This program reads from '" << INPUT_FILE << "', which is generated by PA 12 Exercise 3." << endl;
        cout << "2. PA 12 Exercise 3 reads the first 98,304 values from large100k.txt," << endl;
        cout << "   writes them as text to output_text.txt and as binary to " << INPUT_FILE << "." << endl;
        cout << "3. The binary file may include values up to 100,000 depending on the original file's order." << endl;
        cout << "4. This program sorts the binary file and prints the first and last 5 values." << endl;
        cout << "======================================================" << endl;
    
        ifstream in_size(INPUT_FILE, ios::binary | ios::ate);
        if (!in_size) {
            cerr << "Cannot open input file: " << INPUT_FILE << endl;
            return 1;
        }
        streamsize file_size = in_size.tellg();
        cout << "File '" << INPUT_FILE << "' size: " << file_size << " bytes" << endl;
        if (file_size == 98304 * 4) {
            cout << "Confirmed: File contains 98,304 integers (4 bytes each)." << endl;
        } else {
            cout << "Warning: Unexpected file size. Check your input!" << endl;
        }
        in_size.close();

    // initial sorted runs

    vector<string> runFiles;
    {
        ifstream in{INPUT_FILE, ios::binary};
        if (!in) {
            cerr << "Cannot open input file: " << INPUT_FILE << "\n";
            return 1;
        }

        size_t runCount = 0;
        while (true) {
            vector<int32_t> buffer;
            buffer.reserve(INTS_PER_BLOCK);

            // read up to BLOCK_SIZE bytes (i.e. INTS_PER_BLOCK ints)
            for (size_t i = 0; i < INTS_PER_BLOCK; ++i) {
                int32_t x;
                if (!in.read(reinterpret_cast<char*>(&x), INT_SIZE)) 
                    break;
                buffer.push_back(x);
            }
            if (buffer.empty()) break;

            // sort in-memory
            sort(buffer.begin(), buffer.end());

            // write out to run_N.bin
            string runName = "run_" + to_string(runCount) + ".bin";
            ofstream out{runName, ios::binary};
            out.write(reinterpret_cast<char*>(buffer.data()),
                      buffer.size() * INT_SIZE);
            out.close();

            runFiles.push_back(runName);
            ++runCount;
        }
    }

    // kway merge

    {
        size_t R = runFiles.size();
        vector<ifstream> runs(R);
        for (size_t i = 0; i < R; ++i) {
            runs[i].open(runFiles[i], ios::binary);
            if (!runs[i]) {
                cerr << "Cannot open run file: " << runFiles[i] << "\n";
                return 1;
            }
        }

        // prepare min-heap
        priority_queue<HeapNode, vector<HeapNode>, greater<HeapNode>> minHeap;

        // seed heap with first element of each run
        for (size_t i = 0; i < R; ++i) {
            int32_t v;
            if (runs[i].read(reinterpret_cast<char*>(&v), INT_SIZE))
                minHeap.push({v, i});
        }

        // open final output
        ofstream out{SORTED_OUTPUT, ios::binary};
        if (!out) {
            cerr << "Cannot open output file: " << SORTED_OUTPUT << "\n";
            return 1;
        }

        // repeatedly extract-min and replenish from the same run
        while (!minHeap.empty()) {
            auto node = minHeap.top(); 
            minHeap.pop();

            // write the smallest value
            out.write(reinterpret_cast<char*>(&node.value), INT_SIZE);

            // read next from that run, if any
            int32_t nextVal;
            if (runs[node.runIndex].read(reinterpret_cast<char*>(&nextVal),
                                         INT_SIZE)) {
                minHeap.push({nextVal, node.runIndex});
            }
        }
    }

    // printing first and last 5
    {
        ifstream in{SORTED_OUTPUT, ios::binary};
        if (!in) {
            cerr << "Cannot open sorted file\n";
            return 1;
        }
        vector<int32_t> all;
        int32_t x;
        while (in.read(reinterpret_cast<char*>(&x), INT_SIZE)) {
            all.push_back(x);
        }

        if (all.size() < 10) {
            cerr << "Not enough data to show 5 + 5 values\n";
            return 1;
        }

        cout << "First 5 values:\n";
        for (size_t i = 0; i < 5; ++i) cout << all[i] << " ";
        cout << "\n\nLast 5 values:\n";
        for (size_t i = all.size() - 5; i < all.size(); ++i)
            cout << all[i] << " ";
        cout << "\n";
    }

    return 0;
}
